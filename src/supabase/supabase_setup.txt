-- Make the script fully idempotent by dropping dependent objects first.
DROP TABLE IF EXISTS public.feedbacks CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 1. Create ENUM types for consistent data
-- Dropping existing types if they exist to allow for script re-run during development
DROP TYPE IF EXISTS public.feedback_type CASCADE;
CREATE TYPE public.feedback_type AS ENUM ('bug_report', 'feature_request', 'satisfaction', 'other');

DROP TYPE IF EXISTS public.feedback_severity CASCADE;
CREATE TYPE public.feedback_severity AS ENUM ('low', 'medium', 'high', 'critical');

DROP TYPE IF EXISTS public.feedback_status CASCADE;
CREATE TYPE public.feedback_status AS ENUM ('new', 'acknowledged', 'in_review', 'in_progress', 'resolved', 'wont_fix', 'duplicate');

DROP TYPE IF EXISTS public.user_role CASCADE;
CREATE TYPE public.user_role AS ENUM ('admin', 'client');


-- 2. Create the 'profiles' table to store user roles
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  role user_role NOT NULL DEFAULT 'client',
  PRIMARY KEY (id)
);

COMMENT ON TABLE public.profiles IS 'Stores user profile information, including their role.';


-- 3. Create the 'feedbacks' table to store all feedback submissions
CREATE TABLE IF NOT EXISTS public.feedbacks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  title character varying(100),
  description text NOT NULL,
  type feedback_type NOT NULL,
  severity feedback_severity,
  status feedback_status NOT NULL DEFAULT 'new',
  email character varying,
  name character varying,
  attachment_names text[],
  tracking_id character varying NOT NULL UNIQUE,
  user_id uuid REFERENCES public.profiles ON DELETE SET NULL,
  current_route character varying,
  navigation_history text[]
);

COMMENT ON TABLE public.feedbacks IS 'Collects all feedback entries from users.';


-- 4. Create a helper function to get the current user's role securely
-- This function runs with the permissions of the definer, avoiding RLS recursion.
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS public.user_role
LANGUAGE plpgsql
SECURITY DEFINER
-- Set a search path to an empty string for security and use fully qualified names.
SET search_path = ''
STABLE
AS $$
DECLARE
  user_role public.user_role;
BEGIN
  -- Select the role into the variable. This query runs with definer's privileges, bypassing RLS.
  -- We query public.profiles using an alias 'p' to avoid any ambiguity with the 'role' column name.
  SELECT p.role INTO user_role FROM public.profiles p WHERE p.id = auth.uid();
  RETURN user_role;
END;
$$;

-- Ensure the function is owned by the postgres superuser for SECURITY DEFINER to work correctly.
ALTER FUNCTION public.get_my_role() OWNER TO postgres;

COMMENT ON FUNCTION public.get_my_role() IS 'Returns the role of the currently authenticated user.';


-- 5. Set up Row Level Security (RLS)
-- Enable RLS for both tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.feedbacks ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to avoid conflicts on re-run
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Admins can view all profiles." ON public.profiles;
-- Drop old and new policy names for idempotency during updates
DROP POLICY IF EXISTS "Authenticated users can create feedbacks." ON public.feedbacks;
DROP POLICY IF EXISTS "Public users can create feedbacks." ON public.feedbacks;
DROP POLICY IF EXISTS "Admins can view feedbacks." ON public.feedbacks;
DROP POLICY IF EXISTS "Admins can update feedbacks." ON public.feedbacks;
DROP POLICY IF EXISTS "Admins can delete feedbacks." ON public.feedbacks;


-- Create RLS policies for 'profiles' table
CREATE POLICY "Users can view their own profile." ON public.profiles
  FOR SELECT USING (auth.uid() = id);

-- Use the helper function to prevent infinite recursion
CREATE POLICY "Admins can view all profiles." ON public.profiles
  FOR SELECT USING (public.get_my_role() = 'admin');

-- Create RLS policies for 'feedbacks' table

-- Policy for INSERT: Any user (anonymous or authenticated) can insert a feedback.
CREATE POLICY "Public users can create feedbacks." ON public.feedbacks
  FOR INSERT
  WITH CHECK (true);

-- Policy for SELECT: Only admins can read feedbacks.
CREATE POLICY "Admins can view feedbacks." ON public.feedbacks
  FOR SELECT
  TO authenticated
  USING (public.get_my_role() = 'admin');

-- Policy for UPDATE: Only admins can update feedbacks.
CREATE POLICY "Admins can update feedbacks." ON public.feedbacks
  FOR UPDATE
  TO authenticated
  USING (public.get_my_role() = 'admin')
  WITH CHECK (public.get_my_role() = 'admin');

-- Policy for DELETE: Only admins can delete feedbacks.
CREATE POLICY "Admins can delete feedbacks." ON public.feedbacks
  FOR DELETE
  TO authenticated
  USING (public.get_my_role() = 'admin');


-- 6. Create a function to handle new user sign-ups
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER 
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, role)
  VALUES (
    NEW.id,
    COALESCE((NEW.raw_user_meta_data->>'role')::public.user_role, 'client')
  );
  RETURN NEW;
END;
$$;

-- 7. Create a trigger to call the function when a new user is created
-- Drop trigger if it exists to allow re-running the script
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 8. Set up Storage RLS policies
-- NOTE: Supabase Storage uses the 'storage.objects' table. RLS policies must be
-- applied here to control access to file uploads, downloads, and deletions.

-- Drop existing policies to avoid conflicts on re-run
DROP POLICY IF EXISTS "Allow authenticated uploads to test bucket" ON storage.objects;
DROP POLICY IF EXISTS "Allow public uploads to test bucket" ON storage.objects;
DROP POLICY IF EXISTS "Allow public read access to test bucket" ON storage.objects;

-- Create policy to allow file uploads (INSERT)
-- This policy allows any user (anonymous or authenticated) to upload files
-- into the 'test' bucket.
CREATE POLICY "Allow public uploads to test bucket"
  ON storage.objects FOR INSERT
  TO anon, authenticated
  WITH CHECK (bucket_id = 'test');

-- Create policy to allow file access (SELECT)
-- This policy allows anyone (public) to view/download files from the 'test' bucket.
-- This is required because the application uses `getPublicUrl` to display attachments.
-- If the bucket were not public, a more restrictive policy would be needed.
CREATE POLICY "Allow public read access to test bucket"
  ON storage.objects FOR SELECT
  USING (bucket_id = 'test');